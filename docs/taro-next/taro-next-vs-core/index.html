<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>小程序框架：Taro 2.0与Taro 3.0的核心分析 · 头像小册</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 文章大纲"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="小程序框架：Taro 2.0与Taro 3.0的核心分析 · 头像小册"/><meta property="og:type" content="website"/><meta property="og:url" content="https://hi-our.github.io//hi-face/"/><meta property="og:description" content="## 文章大纲"/><meta property="og:image" content="https://hi-our.github.io//hi-face/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://hi-our.github.io//hi-face/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/hi-face/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/hi-face/js/scrollSpy.js"></script><link rel="stylesheet" href="/hi-face/css/main.css"/><script src="/hi-face/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/hi-face/"><img class="logo" src="/hi-face/img/favicon.ico" alt="头像小册"/><h2 class="headerTitleWithLogo">头像小册</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/hi-face/docs/introduction" target="_self">头像小册</a></li><li class=""><a target="_self"></a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Taro实战</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">介绍<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/hi-face/docs/introduction">开篇介绍</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/book-plan">产品需求设计、项目规划、UI设计的技巧</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">配置<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/hi-face/docs/config/taro-cloud-function">项目搭建-Taro小程序开启云开发模式</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/config/tencent-cloud-ai-face">项目搭建-腾讯云环境配置及特色人工功能介绍</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">小程序知识<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/hi-face/docs/minapp-knowledge/canvas-image-cropper-share">图片裁剪、模糊、保存、分享的技巧</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/minapp-knowledge/canvas-minapp-web">canvas在小程序与web端的不同</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/minapp-knowledge/minapp-to-dark-mode">深色模式在Web端的适配技巧，附带小程序侧的思考</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">原生小程序实战<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/hi-face/docs/minapp-native/face-recognition">原生微信小程序实现人脸识别</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/minapp-native/sticker">原生微信小程序实现头像大头贴效果</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/minapp-native/wear-a-mask">原生小程序实现戴口罩或圣诞帽</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">腾讯云开发实战<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/hi-face/docs/tencent-cloud/picture-speed-up-1-second">图片识别加速，从10秒变为1秒，是怎么做到的呢？</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/tencent-cloud/tencent-minapp-to-web">简单几步，让微信小程序变身 H5 网页</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/tencent-cloud/image-extension-introduction">多种云开发扩展能力，让人脸识别飞起来</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/tencent-cloud/picture-recognition-storage">借助云存储，让大图识别转换真正加速</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/tencent-cloud/avatar-poster-share">海报分享页面的小程序和web端</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/tencent-cloud/login-minapp-web">小程序与Web端的账户体系摸索</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/tencent-cloud/self-page-list">个人中心的制作，包含登录组件的小程序和web端</a></li><li class="navListItem"><a class="navItem" href="/hi-face/docs/tencent-cloud/tencent-image-services">腾讯云功能</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Taro实战<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/hi-face/docs/taro-next/taro-next-vs-core">小程序框架：Taro 2.0与Taro 3.0的核心分析</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">小程序框架：Taro 2.0与Taro 3.0的核心分析</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="文章大纲"></a><a href="#文章大纲" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>文章大纲</h2>
<ul>
<li>React与Nerv适配差异</li>
<li>功能排查列表</li>
<li>项目上线安排</li>
<li>新版本的特色
<ul>
<li>编译速度更快</li>
<li>抽象语法树那一层更统一？</li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="编译图"></a><a href="#编译图" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译图</h2>
<p><img src="https://uploader.shimo.im/f/HU5S9ohp07wkWtXY.png!thumbnail" alt="图片"></p>
<h2><a class="anchor" aria-hidden="true" id="编译工作流与抽象语法树（ast）"></a><a href="#编译工作流与抽象语法树（ast）" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译工作流与抽象语法树（AST）</h2>
<h3><a class="anchor" aria-hidden="true" id="编译时"></a><a href="#编译时" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>编译时</strong></h3>
<p>Taro 的核心部分就是将代码编译成其他端（H5、小程序、React Native 等）代码。一般来说，将一种结构化语言的代码编译成另一种类似的结构化语言的代码包括以下几个步骤：</p>
<p><img src="https://uploader.shimo.im/f/yttbqf6ii44zEccd.png!thumbnail" alt="图片"></p>
<p>首先是 Parse，将代码解析（Parse）成抽象语法树（Abstract Syntex Tree），然后对 AST 进行遍历（traverse）和替换(replace)（这对于前端来说其实并不陌生，可以类比 DOM 树的操作），最后是生成（generate），根据新的 AST 生成编译后的代码。</p>
<p>在本章我们探索了代码究竟是什么：一段结构化的文本，本质是一种叫抽象语法树的复杂拓扑数据结构。也就是说只要我们在简单的情况把代码当做字符串处理，在复杂的情况把代码当做数据处理，这样几乎就可以把一段代码转译成任意的字符串（或数据结构）。我们还介绍了 Babel 一些重要的包以及它们的使用方法，我们了解到 Babel 是使用 JavaScript 处理 JavaScript 代码最成熟的技术方案。</p>
<p>Babel 模块</p>
<p>Babylon（ @babel/parser）</p>
<p>Config配置</p>
<p>如果你是从 Taro CLI 的 dist 文件夹看编译后的代码会发现它相当复杂，那是因为代码会再经过 babel 编译为 ES5。</p>
<p>除了 Page 类型之外，小程序还有 Component 类型，所以 Taro 其实还有 createComponent 方法。由于 Component 在小程序里是全局变量，因此我们还得把 import { Component } from '@tarojs/taro' 的 Component 重命名。</p>
<p>接下来，我们可以对比一下编译后的代码，可以发现，编译后的代码中，React 的核心 render 方法 没有了。同时代码里增加了 BaseComponent 和 createComponent ,它们是 Taro 运行时的核心。</p>
<h3><a class="anchor" aria-hidden="true" id="运行时"></a><a href="#运行时" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>运行时</h3>
<p>createComponent 方法主要做了这样几件事情：</p>
<p>将组件的 state 转换成小程序组件配置对象的 data</p>
<p>将组件的生命周期对应到小程序组件的生命周期</p>
<p>将组件的事件处理函数对应到小程序的事件处理函数</p>
<p>**BaseComponent **大概的 UML 图如下，主要是对 React 的一些核心方法：setState、forceUpdate 等进行了替换和重写，结合前面编译后 render 方法被替换，大家不难猜出：Taro 当前架构只是在开发时遵循了 React 的语法，在代码编译之后实际运行时，和 React 并没有关系。</p>
<p><img src="https://uploader.shimo.im/f/BOCYPJUF1B8qgoWi.png!thumbnail" alt="图片"></p>
<h3><a class="anchor" aria-hidden="true" id="而-createcomponent-主要作用是调用-component-构建页面；对接事件、生命周期等；进行-diff-data-并调用-setdata-方法更新数据。"></a><a href="#而-createcomponent-主要作用是调用-component-构建页面；对接事件、生命周期等；进行-diff-data-并调用-setdata-方法更新数据。" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>而 createComponent 主要作用是调用 Component() 构建页面；对接事件、生命周期等；进行 Diff Data 并调用 setData 方法更新数据。</h3>
<h2><a class="anchor" aria-hidden="true" id="老版本问题"></a><a href="#老版本问题" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>老版本问题</h2>
<p><img src="https://uploader.shimo.im/f/zNvDrJ2KoUgWU9u0.png!thumbnail" alt="图片"></p>
<p><img src="https://uploader.shimo.im/f/ArCZb0EeHQszXovm.png!thumbnail" alt="图片"></p>
<h2><a class="anchor" aria-hidden="true" id="新架构-taro-next-的适配与实现"></a><a href="#新架构-taro-next-的适配与实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新架构 Taro Next 的适配与实现</h2>
<p>这一次，我们站在浏览器的角度来思考前端的本质：无论开发这是用的是什么框架，React 也好，Vue 也罢，最终代码经过运行之后都是调用了浏览器的那几个 BOM/DOM 的 API ，如：createElement、appendChild、removeChild 等。</p>
<p><img src="https://uploader.shimo.im/f/szevBLZRvIQWLJdu.png!thumbnail" alt="图片"></p>
<p>因此，我们创建了 <a href="https://github.com/NervJS/taro/tree/next/packages/taro-runtime">taro-runtime</a> 的包，然后在这个包中实现了 <strong>一套 高效、精简版的 DOM/BOM API</strong>（下面的 UML 图只是反映了几个主要的类的结构和关系）：</p>
<p><img src="https://uploader.shimo.im/f/1yemN8XEXdQxHpaS.png!thumbnail" alt="图片"></p>
<p>然后，我们通过 Webpack 的 <a href="https://webpack.js.org/plugins/provide-plugin/">ProvidePlugin</a> 插件，注入到小程序的逻辑层。</p>
<p><img src="https://uploader.shimo.im/f/Bcpyz7CEFmIsXwpV.png!thumbnail" alt="图片"></p>
<p>这样，在小程序的运行时，就有了 <strong>一套高效、精简版的 DOM/BOM API</strong>。</p>
<h3><a class="anchor" aria-hidden="true" id="react-实现"></a><a href="#react-实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React 实现</h3>
<p>在 DOM/BOM 注入之后，理论上来说，Nerv/Preact 就可以直接运行了。但是 React 有点特殊，因为 React-DOM 包含大量浏览器兼容类的代码，导致包太大，而这部分代码我们是不需要的，因此我们需要做一些定制和优化。</p>
<p>在 React 16+ ，React 的架构如下：</p>
<p><img src="https://uploader.shimo.im/f/mn1f5yraPC883M8g.png!thumbnail" alt="图片"></p>
<p>最上层是 React 的核心部分 react-core ，中间是 react-reconciler，其的职责是维护 VirtualDOM 树，内部实现了 Diff/Fiber 算法，决定什么时候更新、以及要更新什么。</p>
<p>而 Renderer 负责具体平台的渲染工作，它会提供宿主组件、处理事件等等。例如 React-DOM 就是一个渲染器，负责 DOM 节点的渲染和 DOM 事件处理。</p>
<p>因此，我们实现了 <a href="https://github.com/NervJS/taro/tree/next/packages/taro-react">taro-react</a> 包，用来连接 react-reconciler 和 taro-runtime 的 BOM/DOM API：</p>
<p><img src="https://uploader.shimo.im/f/A2CGfX6BflIaLnXk.png!thumbnail" alt="图片"></p>
<p>具体的实现主要分为两步：</p>
<ol>
<li>**实现 react-reconciler 的 hostConfig 配置，即在 hostConfig 的方法中调用对应的 Taro BOM/DOM 的 API。 **</li>
<li><strong>实现 render 函数（类似于 ReactDOM.render）方法，可以看成是创建 Taro DOM Tree 的容器。</strong></li>
</ol>
<p><img src="https://uploader.shimo.im/f/nRk0L5warFAPmzm3.png!thumbnail" alt="图片"></p>
<p>经过上面的步骤，React 代码实际上就可以在小程序的运行时正常运行了，并且会生成 Taro DOM Tree，那么偌大的 Taro DOM Tree 怎样更新到页面呢？</p>
<p>首先，我们将小程序的所有组件挨个进行<strong>模版化处理</strong>，从而得到小程序组件对应的模版，如下图就是小程序的 view 组件经过模版化处理后的样子：</p>
<p><img src="https://uploader.shimo.im/f/Q3J84JPQTOcdaZyJ.png!thumbnail" alt="图片"></p>
<p>然后，我们会：<strong>基于组件的 template，动态 “递归” 渲染整棵树</strong>。</p>
<p>具体流程为先去遍历 Taro DOM Tree 根节点的子元素，再根据每个子元素的类型选择对应的模板来渲染子元素，然后在每个模板中我们又会去遍历当前元素的子元素，以此把整个节点树递归遍历出来。</p>
<p><img src="https://uploader.shimo.im/f/BkGQXX75i04lNcKs.png!thumbnail" alt="图片"></p>
<p>整个 Taro Next 的 React 实现流程图如下：</p>
<p><img src="https://uploader.shimo.im/f/1oNeqrLQFCE2nSop.png!thumbnail" alt="图片"></p>
<h3><a class="anchor" aria-hidden="true" id="vue-实现"></a><a href="#vue-实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue 实现</h3>
<p>别看 React 和 Vue 在开发时区别那么大，其实在实现了 BOM/DOM API 之后，它们之间的区别就很小了。</p>
<p>Vue 和 React 最大的区别就在于运行时的 CreateVuePage 方法，这个方法里进行了一些运行时的处理，比如：生命周期的对齐。</p>
<p><img src="https://uploader.shimo.im/f/1ne7kplIEP8eEV59.png!thumbnail" alt="图片"></p>
<p>其他的部分，如通过 BOM/DOM 方法构建、修改 DOM Tree 及渲染原理，都是和 React 一致的。</p>
<h3><a class="anchor" aria-hidden="true" id="kbone"></a><a href="#kbone" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kbone</h3>
<p>Kbone 内部实现了轻量级的 DOM 和 BOM API，把 DOM 更改的绑定到小程序的视图更改。也就是说，Kbone 并不太关心开发者使用什么框架，只要框架使用的 DOM API 被 Kbone 实现的 DOM API 覆盖到，框架就能通过 Kbone 在小程序运行。Taro Next 也有着同样的思路，但不同的是对 React 的处理。Kbone 通过引入 react-dom 实现渲染，但 react-dom 包含着和合成事件实现和大量浏览器兼容代码。Taro 团队认为这部分代码对小程序平台意义不大，因此和 Remax 一样，通过 react-reconciler 实现了小程序渲染器。</p>
<p>在更新方面，Kbone 以组件为粒度进行更新，每次视图改变小程序 setData 的数据是组件的 DOM 树。而 Remax 和 Taro 更新 setData 的数据则是 DOM 树中已经改变了的的值和它的路径。对比起 Taro 和 Remax，Kbone 的运行时性能会差一些。</p>
<p>另外 Kbone 更为专注于微信小程序开发和 H5 开发，而本节对比的其它三个小程序框架均支持多种平台的小程序开发。</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/hi-face/docs/tencent-cloud/tencent-image-services"><span class="arrow-prev">← </span><span>腾讯云功能</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#文章大纲">文章大纲</a></li><li><a href="#编译图">编译图</a></li><li><a href="#编译工作流与抽象语法树（ast）">编译工作流与抽象语法树（AST）</a><ul class="toc-headings"><li><a href="#编译时"><strong>编译时</strong></a></li><li><a href="#运行时">运行时</a></li><li><a href="#而-createcomponent-主要作用是调用-component-构建页面；对接事件、生命周期等；进行-diff-data-并调用-setdata-方法更新数据。">而 createComponent 主要作用是调用 Component() 构建页面；对接事件、生命周期等；进行 Diff Data 并调用 setData 方法更新数据。</a></li></ul></li><li><a href="#老版本问题">老版本问题</a></li><li><a href="#新架构-taro-next-的适配与实现">新架构 Taro Next 的适配与实现</a><ul class="toc-headings"><li><a href="#react-实现">React 实现</a></li><li><a href="#vue-实现">Vue 实现</a></li><li><a href="#kbone">Kbone</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/hi-face/" class="nav-home"><img src="/hi-face/img/favicon.ico" alt="头像小册" width="66" height="58"/></a><div><h5>Docs</h5><a href="/hi-face/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/hi-face/docs/en/doc2.html">Guides (or other categories)</a><a href="/hi-face/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/hi-face/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/hi-face/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/hi-face/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Hi Our</section></footer></div></body></html>